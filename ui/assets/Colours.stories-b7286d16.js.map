{"version":3,"file":"Colours.stories-b7286d16.js","sources":["../../../src/utils/flatten.ts","../../../src/pages/components/Semantics.jsx","../../../src/pages/principles/Colours.stories.mdx"],"sourcesContent":["export type TFlattenInputObject = {\n  [key: string]: TFlattenInputObject | unknown;\n};\n\nconst flatten = (\n  obj: TFlattenInputObject,\n  arrayModifier: (\n    path: string,\n    value: unknown[],\n  ) => { [key: string]: string } = (path, value) => {\n    const newPath = `${path}!list`;\n    const newValue = value.join(',');\n    return { [newPath]: newValue };\n  },\n): { [key: string]: unknown } => {\n  const dot = (\n    obj: TFlattenInputObject,\n    target: { [key: string]: unknown } = {},\n    path = '',\n  ) => {\n    for (const key in obj) {\n      const value = obj[key];\n      const newPath = path.length > 0 ? `${path}.${key}` : key;\n\n      if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const modified = arrayModifier(newPath, value);\n          Object.assign(target, modified);\n        } else {\n          dot(value as TFlattenInputObject, target, newPath);\n        }\n      } else {\n        target[newPath] = value;\n      }\n    }\n\n    return target;\n  };\n\n  return dot(obj);\n};\n\nexport default flatten;\n","import PropTypes from 'prop-types';\nimport { Fragment } from 'react';\nimport { styled } from 'styled-components';\n\nimport flatten from '#utils/flatten';\n\nimport colorsDocs from '../../../dist/colors.doc.json';\n\n/** @todo find a way of parsing jsDocs on the fly */\n\nimport CopyButton from './CopyButton';\nimport Swatch from './Swatch';\nimport {\n  Headings,\n  Group,\n  GroupHeader,\n  GroupTitle,\n  GroupTable,\n  RowHeading,\n  Cell,\n  CellContents,\n  Description,\n} from './Table';\n\n/**\n * The JSDocs are extracted as part of the build and we pull them in here in\n * order that we can add them as colour descriptions\n */\nconst tokenDescriptions = colorsDocs.reduce(\n  (acc, m) => ({ ...acc, [m.id]: m.description }),\n  {},\n);\n\n/**\n *\n * @param {string} token The location of the color within the theme colour\n * object\n * @param {string} base The name of the base theme that contains all of the\n * colour descriptions\n * @returns {string} The description pertaining to that token\n */\nfunction getTokenDescription(token, base = 'base') {\n  const paragraphString = tokenDescriptions[`${base}.${token}`] || '';\n  const paragraphContent = paragraphString.replaceAll(/<\\/?p>/g, '');\n\n  return paragraphContent;\n}\n\nconst CopyToken = styled(CopyButton)`\n  display: inline-flex;\n  vertical-align: middle;\n`;\n\nconst LongDescription = styled(Description)`\n  display: block;\n  margin-top: ${({ theme }) => theme.spacing.x0_5}px;\n`;\n\nconst Semantics = ({ palette, order }) => {\n  function sortByDefinedOrder(themeA, themeB) {\n    const iA = order.indexOf(themeA);\n    const iB = order.indexOf(themeB);\n\n    if (iA < 1 || iA > iB) {\n      return 1;\n    }\n\n    if (iA < iB) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  const themeNames = Object.keys(palette);\n\n  /*\n    Build a list of themes and sort according to the order provided, otherwise\n    alphabetically\n  */\n  const themes =\n    Array.isArray(order) && order.length\n      ? themeNames.sort(sortByDefinedOrder)\n      : themeNames.sort();\n\n  /**\n   * Build an iterable unique permutation of all possible colour tokens e.g.\n   * [ primary, action.base, action.alt, ... ]\n   */\n  const tokens = Object.values(palette).reduce((acc, colors) => {\n    const themeColorOverrides = flatten(colors);\n    const flattened = Object.keys(themeColorOverrides).filter(\n      (token) => !acc.includes(token),\n    );\n\n    return [...acc, ...flattened];\n  }, []);\n\n  /**\n   * Flatten each theme's semantic colour palette into a map of tokens to their\n   * colour value e.g\n   * {\n   *   base: {\n   *     action.base: '#ec1a2e',\n   *     action.alt: '#a51220',\n   *     ...\n   *   },\n   *   premium: {\n   *     action.base: '#337e81',\n   *     action.alt: '#24585a',\n   *   }\n   *   ...\n   * }\n   */\n  const paletteTokens = Object.entries(palette).reduce(\n    (acc, [theme, colors]) => ({\n      ...acc,\n      [theme]: flatten(colors),\n    }),\n    {},\n  );\n\n  /**\n   * The group name will always be the first element in the dot token. Extract\n   * these into an iterable form so that we can then group the tokens.\n   */\n  const groupNames = tokens.reduce((acc, token) => {\n    const group = token.split('.').at(0);\n\n    if (!acc.includes(group)) {\n      acc.push(group);\n    }\n\n    return acc;\n  }, []);\n\n  /**\n   * Loop over the group names so that we can extract all of the tokens and\n   * colours within e.g.\n   * {\n   *   group: 'action',\n   *   values: [\n   *     {\n   *       token: 'action.base',\n   *       group: 'action,\n   *       variant: 'base',\n   *       description: 'e.g. links, button bg',\n   *       values: [`#ec1a2e`,`#337e81`,`#19d37a`,`#2dccd3`]\n   *     },\n   *     {\n   *       token: 'action.alt',\n   *       group: 'action',\n   *       variant: 'alt',\n   *       description: 'e.g. hovered buttons/links',\n   *       values: [`#a51220`,`#24585a`,`#129455`,`#111f9f`]\n   *     },\n   *     ...\n   *   ]\n   * }\n   */\n  const groups = groupNames.map((group) => {\n    const groupTokens = tokens.filter(\n      (token) => token.split('.').at(0) === group,\n    );\n\n    const tokenThemes = groupTokens.map((token) => ({\n      token,\n      group,\n      variant: token.split('.').at(-1),\n      description: getTokenDescription(token),\n      values: themes.map((theme) => paletteTokens[theme][token] || null),\n    }));\n\n    return {\n      group,\n      description: getTokenDescription(group),\n      values: tokenThemes,\n    };\n  }, []);\n\n  return (\n    <>\n      <Headings colCount={themes.length}>\n        <thead>\n          <tr>\n            <th></th>\n            {themes.map((theme, i) => (\n              <th key={`theme-${i}`}>{theme}</th>\n            ))}\n          </tr>\n        </thead>\n      </Headings>\n      {groups.map(({ group, description, values }, i) => (\n        <Group key={`group-${i}`}>\n          <GroupHeader>\n            <GroupTitle>\n              {group}\n              <Description>{description}</Description>\n            </GroupTitle>\n          </GroupHeader>\n          <GroupTable colCount={themes.length}>\n            <tbody>\n              {values.map(({ token, description, values }, j) => (\n                <tr key={`variant-${j}`}>\n                  <RowHeading>\n                    {token}{' '}\n                    <CopyToken\n                      value={`\\${({ theme }) => theme.color.${token}}`}\n                    />{' '}\n                    {description && (\n                      <LongDescription>{description}</LongDescription>\n                    )}{' '}\n                  </RowHeading>\n                  {values.map((hex, k) => (\n                    <Cell key={`theme-${k}`}>\n                      <CellContents>\n                        <Swatch fill={hex} width={24} height={24} />\n                      </CellContents>\n                    </Cell>\n                  ))}\n                </tr>\n              ))}\n            </tbody>\n          </GroupTable>\n        </Group>\n      ))}\n    </>\n  );\n};\n\nSemantics.propTypes = {\n  palette: PropTypes.object.isRequired,\n  order: PropTypes.arrayOf(PropTypes.string),\n};\n\nexport default Semantics;\n","import { Meta } from '@storybook/addon-docs';\n\nimport * as themes from '#theme/themes';\n\nimport Semantics from '../components/Semantics';\n\n<Meta\n  title=\"Principles/Colours\"\n  parameters={{\n    wrapper: 'section',\n  }}\n/>\n\n<Semantics\n  palette={Object.entries(themes).reduce(\n    (acc, [name, theme]) => ({\n      ...acc,\n      [name]: theme.color,\n    }),\n    {},\n  )}\n  order={['base', 'premium', 'climate', 'sgi']}\n/>\n"],"names":["flatten","obj","arrayModifier","path","value","newPath","newValue","join","dot","target","key","length","Array","isArray","modified","assign","tokenDescriptions","colorsDocs","reduce","acc","m","id","description","getTokenDescription","token","base","paragraphContent","replaceAll","CopyToken","styled","CopyButton","withConfig","componentId","LongDescription","Description","theme","spacing","x0_5","Semantics","palette","order","sortByDefinedOrder","themeA","themeB","iA","indexOf","iB","themeNames","Object","keys","themes","sort","tokens","values","colors","themeColorOverrides","flattened","filter","includes","paletteTokens","entries","groups","group","split","at","push","map","tokenThemes","variant","jsxs","Fragment","jsx","Headings","i","Group","GroupHeader","GroupTitle","GroupTable","j","RowHeading","hex","k","Cell","CellContents","Swatch","propTypes","PropTypes","object","isRequired","arrayOf","string","MDXContent","props","MDXLayout","_provideComponents","_jsx","_createMdxContent","_jsxs","_Fragment","Meta","name","__name","__page","componentMeta","__namedExportsOrder"],"mappings":"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"}