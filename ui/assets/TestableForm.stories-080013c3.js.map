{"version":3,"file":"TestableForm.stories-080013c3.js","sources":["../../../src/components/Form/Form.tsx","../../../src/utils/schema/schemaFunctions.ts","../../../src/utils/schema/schemaEntry.ts","../../../src/utils/schema/schema.ts","../../../src/components/Form/TestableForm/TestableForm.styles.ts","../../../src/hooks/useIndyForm.ts","../../../src/components/Form/TestableForm/TestableForm.tsx"],"sourcesContent":["import React, { FormEvent, PropsWithChildren } from 'react';\n\nconst Form: React.FC<PropsWithChildren> = ({ children, ...props }) => {\n  // Rely on our own validation and styling\n  const noValidate = true;\n\n  /**\n   * We prevent form submission here to prevent key presses (e.g. enter, space) from\n   * submitting the form unintentionally or interfering with custom input behaviour\n   * (i.e. toggle password visibility)\n   *\n   * Forms using this component should make use of a button with a onClick handler to\n   * handle submission instead\n   */\n  const preventSubmission = (e: FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n  };\n\n  return (\n    <form noValidate={noValidate} onSubmit={preventSubmission} {...props}>\n      {children}\n    </form>\n  );\n};\n\nexport default Form;\n","import { capitalise, count, parseString } from '#utils/formValidation';\n\nimport {\n  CharacterType,\n  SchemaFn,\n  SchemaType,\n  UnknownValues,\n  ValidationError,\n  ValidationErrorConfig,\n} from './schema.types';\n\n/*\n * These functions are used to create a schema for a form\n * They are used in the SchemaEntry class to create a chainable\n * schema format, and then accessed in the Schema class to validate\n * form values\n */\n\n/**\n * Return an error if statement is untrue, otherwise return null\n *\n * @param type error type\n * @param statement boolean statement\n * @param message error message to show to user\n * @returns\n */\nconst handler = ({\n  type,\n  condition,\n  message,\n  messageBuilder,\n}: ValidationErrorConfig): ValidationError | null => {\n  if (condition) {\n    return null;\n  }\n\n  return {\n    type,\n    message,\n    messageBuilder,\n  };\n};\n\nexport const isNotEmpty: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n    const isNotEmpty = (parsedValue as string).length > 0;\n\n    return handler({\n      type: 'required',\n      condition: isNotEmpty,\n      message: 'Field is required',\n      messageBuilder: (fieldName: string) => `${fieldName} is required`,\n    });\n  },\n});\n\n// primitive types\nexport const isString: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value);\n    const isString = typeof parsedValue === 'string';\n\n    return handler({\n      type: 'isString',\n      condition: isString,\n      message: 'Field must be text only',\n      messageBuilder: (fieldName: string) => `${fieldName} must be text only`,\n    });\n  },\n});\n\nexport const isNumber: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const isNumeric = !isNaN(value as number);\n\n    return handler({\n      type: 'isNumber',\n      condition: isNumeric,\n      message: 'Field must be a number',\n      messageBuilder: (fieldName: string) => `${fieldName} must be a number`,\n    });\n  },\n});\n\n/**\n * Value must be a valid email address\n * @param config\n */\nexport const isEmail: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n    const regExp = new RegExp(/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i);\n    const isEmail = regExp.test(parsedValue);\n\n    return handler({\n      type: 'isEmail',\n      condition: isEmail,\n      message: 'Please enter a valid email address',\n      messageBuilder: () => `Please enter a valid email address`,\n    });\n  },\n});\n\n/**\n * Value must match to value of another field\n * @param config\n */\nexport const doesMatch = (fieldName: string): SchemaType => ({\n  validate: (value: unknown, values: UnknownValues) => {\n    const parsedValue = parseString(value) as string;\n    const isMatchingField = parsedValue === values[fieldName];\n\n    return handler({\n      type: 'doesMatch',\n      condition: isMatchingField,\n      message: 'Fields must match',\n      messageBuilder: (fieldName: string) => `${fieldName} fields must match`,\n    });\n  },\n});\n\n/**\n * Value must have length of any/particular kind of character\n * @param config\n */\nexport const hasMin = (\n  minLen: number,\n  countType?: CharacterType,\n): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n    const len = count(parsedValue as string, countType);\n\n    const defaults = {\n      type: `hasMin${capitalise(countType || '')}`,\n      condition: len >= minLen,\n    };\n\n    if (countType) {\n      return handler({\n        ...defaults,\n        message: `Must contain minimum ${minLen} ${countType}`,\n        messageBuilder: () => `Must contain minimum ${minLen} ${countType}`,\n      });\n    }\n\n    return handler({\n      ...defaults,\n      message: `Minimum length is ${minLen} characters`,\n      messageBuilder: () => `Minimum length is ${minLen} characters`,\n    });\n  },\n});\n\n/**\n * Value must not exceed length of any/particular kind of character\n * @param config\n */\nexport const hasMax = (\n  maxLength: number,\n  countType?: CharacterType,\n): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n    const length = count(parsedValue as string, countType);\n\n    const defaults = {\n      type: `hasMax${capitalise(countType || '')}`,\n      condition: length <= maxLength,\n    };\n\n    if (countType) {\n      return handler({\n        ...defaults,\n        message: `Must contain maximum ${maxLength} ${countType}`,\n        messageBuilder: () => `Must contain maximum ${maxLength} ${countType}`,\n      });\n    }\n\n    return handler({\n      ...defaults,\n      message: `Maximum length is ${maxLength} characters`,\n      messageBuilder: () => `Maximum length is ${maxLength} characters`,\n    });\n  },\n});\n\n/**\n * Value must be within a range of length of any/particular kind of character\n * @param config\n */\nexport const hasRange = (\n  minLength: number,\n  maxLength: number,\n  countType?: CharacterType,\n): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = Number(value);\n\n    const defaults = {\n      type: `hasRange${capitalise(countType || '')}`,\n      condition: parsedValue >= minLength && parsedValue <= maxLength,\n    };\n\n    if (countType) {\n      return handler({\n        ...defaults,\n        message: `Must contain a minimum value of ${minLength} ${countType} and a maximum value of ${maxLength} ${countType}`,\n        messageBuilder: () =>\n          `Must contain a minimum value of ${minLength} ${countType} and a maximum value of ${maxLength} ${countType}`,\n      });\n    }\n\n    return handler({\n      ...defaults,\n      message: `Minimum value is ${minLength} characters and maximum value is ${maxLength} characters`,\n      messageBuilder: () =>\n        `Minimum value is ${minLength} characters and maximum value is ${maxLength} characters`,\n    });\n  },\n});\n","import { UnknownFn, SchemaFn, Validator } from './schema.types';\nimport {\n  doesMatch,\n  hasMin,\n  hasMax,\n  isEmail,\n  isNumber,\n  isString,\n  hasRange,\n} from './schemaFunctions';\n\nconst NO_PARAMS = [] as unknown[];\n\n/**\n * SchemaEntry class designed to be used with the Schema class to\n * create a chainable schema format for validating flat data e.g. new Schema().string().isEmail(0)\n */\nclass SchemaEntry {\n  name: string;\n  isRequired?: boolean = false;\n  validators: Validator[] = [];\n\n  /**\n   * @param name name of the field to be used in messaging\n   */\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  private initialise(fns: Validator[]) {\n    this.validators = fns;\n  }\n\n  private checkValid() {\n    if (!this.validators.length) {\n      throw new Error('No validators set');\n    }\n  }\n\n  // primitives\n  string(): SchemaEntry {\n    this.initialise([[isString, NO_PARAMS]]);\n    return this;\n  }\n\n  number(): SchemaEntry {\n    this.initialise([[isNumber, NO_PARAMS]]);\n    return this;\n  }\n\n  // special\n  required(): SchemaEntry {\n    this.isRequired = true;\n\n    return this;\n  }\n\n  // conditions\n\n  /**\n   * A check to validate field value is an email\n   *\n   * @returns SchemaEntry\n   */\n  isEmail(...args: Parameters<SchemaFn>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([isEmail as UnknownFn, args]);\n    return this;\n  }\n\n  /**\n   * A check to validate field value matches another field's value\n   *\n   * @param fieldName\n   * @returns SchemaEntry\n   */\n  doesMatch(...args: Parameters<typeof doesMatch>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([doesMatch as UnknownFn, args]);\n    return this;\n  }\n\n  /**\n   * A check to validate field has a minimum length or minimum\n   * count of letters/digits\n   *\n   * @param minLength\n   * @param countType\n   * @returns SchemaEntry\n   */\n  hasMin(...params: Parameters<typeof hasMin>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([hasMin as UnknownFn, params]);\n    return this;\n  }\n\n  /**\n   * A check to validate field has a maximum length or maximum\n   * count of letters/digits\n   *\n   * @param minLength\n   * @param countType\n   * @returns SchemaEntry\n   */\n  hasMax(...params: Parameters<typeof hasMax>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([hasMax as UnknownFn, params]);\n    return this;\n  }\n\n  /**\n   * A check to validate field has a range of length or count of\n   * letters/digits\n   *\n   * @param minLength\n   * @param maxLength\n   * @param countType\n   * @returns SchemaEntry\n   */\n  hasRange(...params: Parameters<typeof hasRange>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([hasRange as UnknownFn, params]);\n    return this;\n  }\n}\n\nexport default SchemaEntry;\n","import SchemaEntry from '#utils/schema/schemaEntry';\n\nimport { ValidationError, ValidationErrors, Validator } from './schema.types';\nimport { isNotEmpty } from './schemaFunctions';\n\n/**\n * Schema class made up of SchemaEntry objects, creating a\n * chainable schema format for validating data\n */\nclass Schema<T> {\n  private self: Record<keyof T, SchemaEntry>;\n  fields: (keyof T)[];\n  names: Record<keyof T, string>;\n  errors: ValidationErrors<T> = {} as ValidationErrors<T>;\n\n  constructor(schema: Record<keyof T, SchemaEntry>) {\n    this.self = schema;\n    this.fields = Object.keys(schema) as (keyof T)[];\n    this.names = Object.entries(schema).reduce(\n      (acc, [key, value]) => ({\n        ...acc,\n        [key]: (value as SchemaEntry).name,\n      }),\n      {} as Record<keyof T, string>,\n    );\n\n    return this;\n  }\n\n  /**\n   * Add a schema entry to the schema\n   * @param name human readable field name to be used in messaging\n   * @returns a new SchemaEntry object\n   */\n  static add(name: string) {\n    return new SchemaEntry(name);\n  }\n\n  /**\n   * @param field field ID/key\n   * @returns SchemaEntry for the given field\n   */\n  get(field: keyof T) {\n    return this.self[field];\n  }\n\n  /**\n   * @param field field ID/key\n   * @returns SchemaEntry for the given field\n   */\n  getErrors(field: keyof T) {\n    return this.errors[field as keyof T];\n  }\n\n  /**\n   * @param field field ID/key\n   * @param errors  validation errors to set for the given field\n   */\n  setErrors(field: keyof T, errors: ValidationError[] | null) {\n    if (!errors || errors.length === 0) {\n      // remove key from errors object so this can\n      // be easily evaluated as falsey\n      delete this.errors[field as keyof T];\n    } else {\n      this.errors[field as keyof T] = errors;\n    }\n  }\n\n  /**\n   * Validate a value against the schema for a singular field\n   *\n   * @param key field ID/key\n   * @param value field value\n   * @param values an object containing all field vales, required for some validations (e.g. isMatch)\n   * @returns an array of errors for the given field\n   */\n  validate(field: keyof T, value: unknown, values: Record<string, unknown>) {\n    const entry = this.get(field);\n\n    if (!entry) {\n      return;\n    }\n\n    // if a field is required but empty we should prioritise that error over\n    // any other errors\n    const isRequired = entry.isRequired;\n    const fieldEmptyError = isNotEmpty().validate(value, values);\n\n    if (isRequired && fieldEmptyError) {\n      this.setErrors(field, [fieldEmptyError]);\n      return this.getErrors(field as keyof T);\n    }\n\n    // field has values so continue with remaining validation\n    const freshErrors = entry.validators.reduce(\n      (acc: ValidationError[], validatorCreator: Validator) => {\n        const [creator, args] = validatorCreator;\n\n        const validator = creator(...args);\n        const error = validator.validate(value, values);\n\n        if (error) {\n          return [...acc, error];\n        }\n\n        return acc;\n      },\n      [] as ValidationError[],\n    );\n\n    this.setErrors(field, freshErrors);\n    return this.getErrors(field as keyof T);\n  }\n}\nexport default Schema;\n","import { styled } from 'styled-components';\n\nexport const Wrapper = styled.div`\n  width: 500px;\n  padding: ${({ theme }) => theme.spacing.x2}px;\n`;\n","import { useEffect } from 'react';\nimport { FieldValues, Path, UseFormProps, useForm } from 'react-hook-form';\n\nimport { InputState } from '#components/Form/Input/Input.types';\n\nimport { errorId, hintId, resolver } from '#utils/formValidation';\nimport { Schema } from '#utils/schema/';\nimport { ValidationErrors } from '#utils/schema/schema.types';\n\n/**\n * This builds on top of the react-hook-form library\n * to provide a consistent handling of form state\n *\n * Designed to be used with TextInput & PasswordInput\n * and could be extended to support other input types\n *\n */\nconst useIndyForm = <T extends FieldValues>(\n  schema: Schema<T>,\n  options: UseFormProps<T> = {},\n) => {\n  if (!schema) {\n    throw new Error(\n      'No schema provided! Please provide a schema to useIndyForm',\n    );\n  }\n\n  const methods = useForm<T>({\n    mode: 'onTouched',\n    resolver: resolver<T>(schema as Schema<T>),\n    ...options,\n  });\n\n  const { formState, getValues, setError } = methods;\n\n  useEffect(() => {\n    const schemaFields = schema.fields;\n    const formFields = Object.keys(getValues());\n\n    const missingFields = schemaFields.filter(\n      (field) => !formFields.includes(field as string),\n    );\n\n    if (missingFields.length > 0) {\n      throw new Error(\n        `Fields [\"${missingFields.join(\n          '\", \"',\n        )}\"] are included in the schema but missing or inaccessible by React Hook Form`,\n      );\n    }\n  }, [getValues, schema.fields]);\n\n  const getTextInputError = (id: keyof T) => {\n    const formErrors = formState.errors as ValidationErrors<T>;\n    const textInputErrors = formErrors[id];\n\n    if (textInputErrors) {\n      return textInputErrors[0].messageBuilder(schema.names[id]);\n    }\n\n    return undefined;\n  };\n\n  const getTextInputState = (id: keyof T) => {\n    const formErrored = !!formState.errors['root'];\n    const fieldIsErrored = !!formState.errors[id];\n    const fieldHasErrored =\n      formState.dirtyFields[id as string] && !fieldIsErrored;\n\n    if (fieldIsErrored || formErrored) {\n      return InputState.ERROR;\n    }\n\n    if (fieldHasErrored) {\n      return InputState.SUCCESS;\n    }\n\n    return InputState.DEFAULT;\n  };\n\n  const registerControlledInput = (id: keyof T) => {\n    const fieldIsRequired = schema.get(id)?.isRequired || false;\n    const fieldError = getTextInputError(id);\n    const fieldState = getTextInputState(id);\n\n    return {\n      id: id as keyof T,\n      state: fieldState,\n      message: fieldError,\n      required: fieldIsRequired,\n      'aria-required': fieldIsRequired,\n      'aria-invalid': fieldError === 'error',\n      // Feb 2024 - errors should be announced by aria-errormessage in the future,\n      // but it is currently not well supported sccross screen readers/browsers\n      'aria-describedby': `${errorId(id)} ${hintId(id)}`,\n    };\n  };\n\n  const setFormError = (message: string) => {\n    setError('root', { message });\n  };\n\n  const setFieldError = (name: Path<T>, message: string) => {\n    setError(name, { message }, { shouldFocus: true });\n  };\n\n  const getFormError = () => getTextInputError('root');\n  const getFieldErrors = () =>\n    schema.fields.map(getTextInputError).filter(Boolean) as string[];\n  return {\n    registerControlledInput,\n    methods: {\n      ...methods,\n      setFormError,\n      setFieldError,\n      getFormError,\n      getFieldErrors,\n    },\n    formState: {\n      ...formState,\n      errors: formState.errors as ValidationErrors<T>,\n    },\n  };\n};\n\nexport default useIndyForm;\n","import React from 'react';\nimport { SubmitHandler } from 'react-hook-form';\n\nimport Button from '#components/Button';\nimport {\n  Form,\n  FormProvider,\n  TextInput,\n  PasswordInput,\n  SelectInput,\n  Schema,\n} from '#components/Form';\n\nimport { Wrapper } from './TestableForm.styles';\n\nimport useIndyForm from '#hooks/useIndyForm';\n\ntype ExampleFormData = {\n  fullName: string;\n  email: string;\n  password: string;\n  birthYear: string;\n};\n\ntype TestableFormProps = { onSubmit: SubmitHandler<ExampleFormData> };\n\nexport const schema = new Schema<ExampleFormData>({\n  fullName: Schema.add('Full name').string(),\n  email: Schema.add('Email address').string().isEmail().required(),\n  password: Schema.add('Password')\n    .string()\n    .hasMin(1, 'digits')\n    .hasMin(6, 'letters')\n    .required(),\n  birthYear: Schema.add('Birth year').number().required(),\n});\n\n/**\n * This form exists to demonstrate how to use the useIndyForm hook\n * alongside the Form, TextInput and PasswordInput components\n *\n * It us also used for testing functionality in a form context\n * with full validation and error handling, and providing a\n * component in storybook for visual testing\n */\nconst TestableForm: React.FC<TestableFormProps> = ({ onSubmit }) => {\n  const { methods, registerControlledInput } = useIndyForm(schema);\n  const { handleSubmit, formState } = methods;\n\n  return (\n    <Wrapper>\n      <FormProvider {...methods}>\n        <Form>\n          <TextInput label=\"Name\" {...registerControlledInput('fullName')} />\n          <TextInput\n            type=\"email\"\n            label=\"Email address\"\n            helpText=\"Add an email address\"\n            {...registerControlledInput('email')}\n          />\n          <PasswordInput\n            label=\"Password\"\n            helpText=\"Make it a good one\"\n            {...registerControlledInput('password')}\n          />\n          <SelectInput\n            label=\"Birth year\"\n            options={[\n              { value: '1970', label: '1970' },\n              { value: '1980', label: '1980' },\n              { value: '1990', label: '1990' },\n            ]}\n            {...registerControlledInput('birthYear')}\n          ></SelectInput>\n          <Button\n            type=\"submit\"\n            disabled={!formState.isValid}\n            onClick={handleSubmit(onSubmit)}\n          >\n            Sign up\n          </Button>\n        </Form>\n      </FormProvider>\n    </Wrapper>\n  );\n};\n\nexport default TestableForm;\n"],"names":["Form","__name","children","preventSubmission","e","jsx","props","handler","type","condition","message","messageBuilder","isNotEmpty","validate","value","parseString","length","fieldName","isString","isNumber","isNumeric","isNaN","isEmail","parsedValue","RegExp","test","doesMatch","values","isMatchingField","hasMin","minLen","countType","len","count","defaults","capitalise","hasMax","maxLength","hasRange","minLength","Number","NO_PARAMS","SchemaEntry","constructor","name","isRequired","validators","initialise","fns","checkValid","Error","string","number","required","args","push","params","Schema","schema","self","fields","names","errors","Object","keys","entries","reduce","acc","key","add","get","field","getErrors","setErrors","entry","fieldEmptyError","freshErrors","validatorCreator","creator","error","Wrapper","styled","div","withConfig","componentId","theme","spacing","x2","useIndyForm","options","methods","useForm","mode","resolver","formState","getValues","setError","useEffect","schemaFields","formFields","missingFields","filter","includes","join","getTextInputError","id","textInputErrors","undefined","getTextInputState","formErrored","fieldIsErrored","fieldHasErrored","dirtyFields","InputState","ERROR","SUCCESS","DEFAULT","registerControlledInput","fieldIsRequired","fieldError","fieldState","state","errorId","hintId","setFormError","setFieldError","shouldFocus","getFormError","getFieldErrors","map","Boolean","TestableForm","onSubmit","handleSubmit","FormProvider","jsxs","TextInput","PasswordInput","SelectInput","Button"],"mappings":"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"}