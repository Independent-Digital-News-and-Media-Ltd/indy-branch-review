{"version":3,"file":"TestableForm.stories-57cd5ff9.js","sources":["../../../src/components/Form/Form.tsx","../../../src/utils/schema/schemaFunctions.ts","../../../src/utils/schema/schemaEntry.ts","../../../src/utils/schema/schema.ts","../../../src/components/Form/TestableForm/TestableForm.styles.ts","../../../src/hooks/useIndyForm.ts","../../../src/components/Form/TestableForm/TestableForm.tsx"],"sourcesContent":["import React, { FormEvent, PropsWithChildren } from 'react';\n\nconst Form: React.FC<PropsWithChildren> = ({ children, ...props }) => {\n  // Rely on our own validation and styling\n  const noValidate = true;\n\n  /**\n   * We prevent form submission here to prevent key presses (e.g. enter, space) from\n   * submitting the form unintentionally or interfering with custom input behaviour\n   * (i.e. toggle password visibility)\n   *\n   * Forms using this component should make use of a button with a onClick handler to\n   * handle submission instead\n   */\n  const preventSubmission = (e: FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n  };\n\n  return (\n    <form noValidate={noValidate} onSubmit={preventSubmission} {...props}>\n      {children}\n    </form>\n  );\n};\n\nexport default Form;\n","import { capitalise, count, parseString } from '#utils/formValidation';\n\nimport {\n  CharacterType,\n  PrimitiveType,\n  SchemaFn,\n  SchemaType,\n  UnknownValues,\n  ValidationError,\n  ValidationErrorConfig,\n} from './schema.types';\n\n/*\n * These functions are used to create a schema for a form\n * They are used in the SchemaEntry class to create a chainable\n * schema format, and then accessed in the Schema class to validate\n * form values\n */\n\n/**\n * Return an error if statement is untrue, otherwise return null\n *\n * @param type error type\n * @param statement boolean statement\n * @param message error message to show to user\n * @returns\n */\nconst handler = ({\n  type,\n  condition,\n  message,\n  messageBuilder,\n}: ValidationErrorConfig): ValidationError | null => {\n  if (condition) {\n    return null;\n  }\n\n  return {\n    type,\n    message,\n    messageBuilder,\n  };\n};\n\n// primitive types\nexport const isString: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value);\n    const isString = typeof parsedValue === 'string';\n\n    return handler({\n      type: 'isString',\n      condition: isString,\n      message: 'Field must be text only',\n      messageBuilder: (fieldName: string) => `${fieldName} must be text only`,\n    });\n  },\n});\n\nexport const isNumber: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const isNumeric = !isNaN(value as number);\n\n    return handler({\n      type: 'isNumber',\n      condition: isNumeric,\n      message: 'Field must be a number',\n      messageBuilder: (fieldName: string) => `${fieldName} must be a number`,\n    });\n  },\n});\n\nexport const isBoolean: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const isBoolean = typeof value === 'boolean';\n\n    return handler({\n      type: 'isBoolean',\n      condition: isBoolean,\n      message: 'Field must be true or false',\n      messageBuilder: (fieldName: string) =>\n        `${fieldName} must be true or false`,\n    });\n  },\n});\n\nexport const isNotEmpty = (type: PrimitiveType = 'string'): SchemaType => ({\n  validate: (value: unknown) => {\n    if (type === 'boolean') {\n      return isBoolean().validate(value, {});\n    }\n\n    const parsedValue = parseString(value) as string;\n    const isNotEmpty = (parsedValue as string).length > 0;\n\n    return handler({\n      type: 'required',\n      condition: isNotEmpty,\n      message: 'Field is required',\n      messageBuilder: (fieldName: string) => `${fieldName} is required`,\n    });\n  },\n});\n\n/**\n * Value must be a valid email address\n * @param config\n */\nexport const isEmail: SchemaFn = () => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n    const regExp = new RegExp(/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/i);\n    const isEmail = regExp.test(parsedValue);\n\n    return handler({\n      type: 'isEmail',\n      condition: isEmail,\n      message: 'Please enter a valid email address',\n      messageBuilder: () => `Please enter a valid email address`,\n    });\n  },\n});\n\n/**\n * Value must match to value of another field\n * @param config\n */\nexport const doesMatch = (fieldName: string): SchemaType => ({\n  validate: (value: unknown, values: UnknownValues) => {\n    const parsedValue = parseString(value) as string;\n    const isMatchingField = parsedValue === values[fieldName];\n\n    return handler({\n      type: 'doesMatch',\n      condition: isMatchingField,\n      message: 'Fields must match',\n      messageBuilder: (fieldName: string) => `${fieldName} fields must match`,\n    });\n  },\n});\n\n/**\n * Value must have length of any/particular kind of character\n * @param config\n */\nexport const hasMin = (\n  minLen: number,\n  countType?: CharacterType,\n): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n    const len = count(parsedValue as string, countType);\n\n    const defaults = {\n      type: `hasMin${capitalise(countType || '')}`,\n      condition: len >= minLen,\n    };\n\n    if (countType) {\n      return handler({\n        ...defaults,\n        message: `Must contain minimum ${minLen} ${countType}`,\n        messageBuilder: () => `Must contain minimum ${minLen} ${countType}`,\n      });\n    }\n\n    return handler({\n      ...defaults,\n      message: `Minimum length is ${minLen} characters`,\n      messageBuilder: () => `Minimum length is ${minLen} characters`,\n    });\n  },\n});\n\n/**\n * Value must not exceed length of any/particular kind of character\n * @param config\n */\nexport const hasMax = (\n  maxLength: number,\n  countType?: CharacterType,\n): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n    const length = count(parsedValue as string, countType);\n\n    const defaults = {\n      type: `hasMax${capitalise(countType || '')}`,\n      condition: length <= maxLength,\n    };\n\n    if (countType) {\n      return handler({\n        ...defaults,\n        message: `Must contain maximum ${maxLength} ${countType}`,\n        messageBuilder: () => `Must contain maximum ${maxLength} ${countType}`,\n      });\n    }\n\n    return handler({\n      ...defaults,\n      message: `Maximum length is ${maxLength} characters`,\n      messageBuilder: () => `Maximum length is ${maxLength} characters`,\n    });\n  },\n});\n\n/**\n * Value must be within a range of length of any/particular kind of character\n * @param config\n */\nexport const hasRange = (\n  minLength: number,\n  maxLength: number,\n  countType?: CharacterType,\n): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = Number(value);\n\n    const defaults = {\n      type: `hasRange${capitalise(countType || '')}`,\n      condition: parsedValue >= minLength && parsedValue <= maxLength,\n    };\n\n    if (countType) {\n      return handler({\n        ...defaults,\n        message: `Must contain a minimum value of ${minLength} ${countType} and a maximum value of ${maxLength} ${countType}`,\n        messageBuilder: () =>\n          `Must contain a minimum value of ${minLength} ${countType} and a maximum value of ${maxLength} ${countType}`,\n      });\n    }\n\n    return handler({\n      ...defaults,\n      message: `Minimum value is ${minLength} characters and maximum value is ${maxLength} characters`,\n      messageBuilder: () =>\n        `Minimum value is ${minLength} characters and maximum value is ${maxLength} characters`,\n    });\n  },\n});\n\n/**\n * Value must not contain any spaces\n * @param config\n */\nexport const containsNoSpaces = (): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n\n    const defaults = {\n      type: 'containsNoSpaces',\n      condition: !parsedValue.includes(' '),\n    };\n\n    return handler({\n      ...defaults,\n      message: 'Must not contain any spaces',\n      messageBuilder: () => 'Must not contain any spaces',\n    });\n  },\n});\n\n/**\n * Value must match a specific regular expression pattern\n * @param regex\n * @param config\n */\nexport const matchesRegex = (regex: RegExp): SchemaType => ({\n  validate: (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n\n    const defaults = {\n      type: 'matchesRegex',\n      condition: regex.test(parsedValue),\n    };\n\n    return handler({\n      ...defaults,\n      message: 'Field does not match the required format',\n      messageBuilder: () => 'Field does not match the required format',\n    });\n  },\n});\n\n/**\n * Value must pass the provided custom validation\n * @param validator\n * @param config\n */\nexport const hasCustomValidation = (\n  validator: (value: string) => boolean | Promise<boolean>,\n): SchemaType => ({\n  validate: async (value: unknown) => {\n    const parsedValue = parseString(value) as string;\n\n    const defaults = {\n      type: 'hasCustomValidation',\n      condition: await (async () => {\n        try {\n          return await validator(parsedValue);\n        } catch {\n          return false;\n        }\n      })(),\n    };\n\n    return handler({\n      ...defaults,\n      message: 'Field does not pass the custom validation',\n      messageBuilder: () => 'Field does not pass the custom validation',\n    });\n  },\n});\n","import { UnknownFn, SchemaFn, Validator, PrimitiveType } from './schema.types';\nimport {\n  doesMatch,\n  hasMin,\n  hasMax,\n  isEmail,\n  isNumber,\n  isString,\n  hasRange,\n  containsNoSpaces,\n  matchesRegex,\n  isBoolean,\n  hasCustomValidation,\n} from './schemaFunctions';\n\nconst NO_PARAMS = [] as unknown[];\n\n/**\n * SchemaEntry class designed to be used with the Schema class to\n * create a chainable schema format for validating flat data e.g. new Schema().string().isEmail(0)\n */\nclass SchemaEntry {\n  name: string;\n  primitiveType: PrimitiveType = 'string';\n  isRequired?: boolean = false;\n  validators: Validator[] = [];\n\n  /**\n   * @param name name of the field to be used in messaging\n   */\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  private initialise(primitiveType: PrimitiveType, fns: Validator[]) {\n    this.primitiveType = primitiveType;\n    this.validators = fns;\n  }\n\n  private checkValid() {\n    if (!this.validators.length) {\n      throw new Error('No validators set');\n    }\n  }\n\n  // primitives\n  string(): SchemaEntry {\n    this.initialise('string', [[isString, NO_PARAMS]]);\n    return this;\n  }\n\n  number(): SchemaEntry {\n    this.initialise('number', [[isNumber, NO_PARAMS]]);\n    return this;\n  }\n\n  boolean(): SchemaEntry {\n    this.initialise('boolean', [[isBoolean, NO_PARAMS]]);\n    return this;\n  }\n\n  // special\n  required(): SchemaEntry {\n    this.isRequired = true;\n\n    return this;\n  }\n\n  // conditions\n\n  /**\n   * A check to validate field value is an email\n   *\n   * @returns SchemaEntry\n   */\n  isEmail(...args: Parameters<SchemaFn>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([isEmail as UnknownFn, args]);\n    return this;\n  }\n\n  /**\n   * A check to validate field value matches another field's value\n   *\n   * @param fieldName\n   * @returns SchemaEntry\n   */\n  doesMatch(...args: Parameters<typeof doesMatch>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([doesMatch as UnknownFn, args]);\n    return this;\n  }\n\n  /**\n   * A check to validate field has a minimum length or minimum\n   * count of letters/digits\n   *\n   * @param minLength\n   * @param countType\n   * @returns SchemaEntry\n   */\n  hasMin(...params: Parameters<typeof hasMin>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([hasMin as UnknownFn, params]);\n    return this;\n  }\n\n  /**\n   * A check to validate field has a maximum length or maximum\n   * count of letters/digits\n   *\n   * @param minLength\n   * @param countType\n   * @returns SchemaEntry\n   */\n  hasMax(...params: Parameters<typeof hasMax>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([hasMax as UnknownFn, params]);\n    return this;\n  }\n\n  /**\n   * A check to validate field has a range of length or count of\n   * letters/digits\n   *\n   * @param minLength\n   * @param maxLength\n   * @param countType\n   * @returns SchemaEntry\n   */\n  hasRange(...params: Parameters<typeof hasRange>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([hasRange as UnknownFn, params]);\n    return this;\n  }\n\n  /**\n   * A check to validate field contains no spaces\n   * @returns SchemaEntry\n   */\n  containsNoSpaces(\n    ...params: Parameters<typeof containsNoSpaces>\n  ): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([containsNoSpaces as UnknownFn, params]);\n    return this;\n  }\n\n  /**\n   * A check to validate field matches the required format\n   * @returns SchemaEntry\n   */\n  matchesRegex(...params: Parameters<typeof matchesRegex>): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([matchesRegex as UnknownFn, params]);\n    return this;\n  }\n\n  /**\n   * A check to validate field passes the provided custom validation\n   * @returns SchemaEntry\n   */\n  hasCustomValidation(\n    ...params: Parameters<typeof hasCustomValidation>\n  ): SchemaEntry {\n    this.checkValid();\n\n    this.validators.push([hasCustomValidation as UnknownFn, params]);\n    return this;\n  }\n}\n\nexport default SchemaEntry;\n","import SchemaEntry from '#utils/schema/schemaEntry';\n\nimport { ValidationError, ValidationErrors, Validator } from './schema.types';\nimport { isNotEmpty } from './schemaFunctions';\n\n/**\n * Schema class made up of SchemaEntry objects, creating a\n * chainable schema format for validating data\n */\nclass Schema<T> {\n  private self: Record<keyof T, SchemaEntry>;\n  fields: (keyof T)[];\n  names: Record<keyof T, string>;\n  errors: ValidationErrors<T> = {} as ValidationErrors<T>;\n  validationHints: Record<\n    keyof T,\n    { [key: string]: { passes: boolean; hint?: string } }\n  >;\n\n  constructor(schema: Record<keyof T, SchemaEntry>) {\n    this.self = schema;\n    this.fields = Object.keys(schema) as (keyof T)[];\n    this.names = Object.entries(schema).reduce(\n      (acc, [key, value]) => ({\n        ...acc,\n        [key]: (value as SchemaEntry).name,\n      }),\n      {} as Record<keyof T, string>,\n    );\n    this.validationHints = {} as Record<\n      keyof T,\n      { [key: string]: { passes: boolean; hint?: string } }\n    >;\n    this.initValidationHints();\n\n    return this;\n  }\n\n  /**\n   * Add a schema entry to the schema\n   * @param name human readable field name to be used in messaging\n   * @returns a new SchemaEntry object\n   */\n  static add(name: string) {\n    return new SchemaEntry(name);\n  }\n\n  /**\n   * @param field field ID/key\n   * @returns SchemaEntry for the given field\n   */\n  get(field: keyof T) {\n    return this.self[field];\n  }\n\n  /**\n   * @param field field ID/key\n   * @returns SchemaEntry for the given field\n   */\n  getErrors(field: keyof T) {\n    return this.errors[field as keyof T];\n  }\n\n  /**\n   * @param field field ID/key\n   * @param errors  validation errors to set for the given field\n   */\n  setErrors(field: keyof T, errors: ValidationError[] | null) {\n    if (!errors || errors.length === 0) {\n      // remove key from errors object so this can\n      // be easily evaluated as falsey\n      delete this.errors[field as keyof T];\n    } else {\n      this.errors[field as keyof T] = errors;\n    }\n  }\n\n  getValidationHints(field: keyof T) {\n    return this.validationHints[field];\n  }\n\n  setValidationHints(\n    field: keyof T,\n    key: string,\n    passes: boolean,\n    hint?: string,\n  ) {\n    this.validationHints[field] = {\n      ...this.validationHints[field],\n      [key]: { passes, hint },\n    };\n  }\n\n  initValidationHint(field: keyof T) {\n    const entry = this.get(field);\n    entry.validators.forEach((validatorCreator) => {\n      const [, args] = validatorCreator;\n      const [val, label, hint] = args as [unknown, unknown?, string?];\n      if (hint) {\n        this.setValidationHints(field, [val, label].join('.'), false, hint);\n      }\n    });\n  }\n\n  initValidationHints() {\n    this.fields.forEach((field) => {\n      this.initValidationHint(field);\n    });\n  }\n\n  resetValidationHints(field: keyof T) {\n    // set all hints to false\n    if (this.validationHints[field]) {\n      Object.keys(this.validationHints[field]).forEach((key) => {\n        this.validationHints[field][key].passes = false;\n      });\n    }\n  }\n\n  /**\n   * Validate a value against the schema for a singular field\n   *\n   * @param key field ID/key\n   * @param value field value\n   * @param values an object containing all field vales, required for some validations (e.g. isMatch)\n   * @returns an array of errors for the given field\n   */\n  async validate(\n    field: keyof T,\n    value: unknown,\n    values: Record<string, unknown>,\n  ) {\n    const entry = this.get(field);\n\n    if (!entry) {\n      return;\n    }\n\n    // if a field is required but empty we should prioritise that error over\n    // any other errors\n    const isRequired = entry.isRequired;\n\n    const fieldEmptyError = await isNotEmpty(entry.primitiveType).validate(\n      value,\n      values,\n    );\n\n    if (isRequired && fieldEmptyError) {\n      this.setErrors(field, [fieldEmptyError]);\n      this.resetValidationHints(field);\n      return this.getErrors(field as keyof T);\n    }\n\n    // field has values so continue with remaining validation\n    const freshErrors = await Promise.all(\n      entry.validators.map(async (validatorCreator: Validator) => {\n        const [creator, args] = validatorCreator;\n        const [val, label, hint] = args as [unknown, unknown?, string?];\n        const validator = creator(...args);\n        const error = await validator.validate(value, values);\n        if (hint) {\n          this.setValidationHints(\n            field,\n            [val, label].join('.'),\n            !error && value !== '',\n            hint,\n          );\n        }\n        return error;\n      }),\n    );\n    const freshErrorsFiltered = freshErrors.filter(\n      (error) => error,\n    ) as ValidationError[];\n    this.setErrors(field, freshErrorsFiltered);\n    return this.getErrors(field as keyof T);\n  }\n}\nexport default Schema;\n","import { styled } from 'styled-components';\n\nexport const Wrapper = styled.div`\n  width: 500px;\n  padding: ${({ theme }) => theme.spacing.x2}px;\n`;\n","import { useEffect } from 'react';\nimport { FieldValues, Path, UseFormProps, useForm } from 'react-hook-form';\n\nimport { InputState } from '#components/Form/Input/Input.types';\n\nimport { errorId, hintId, resolver } from '#utils/formValidation';\nimport { Schema } from '#utils/schema/';\nimport { ValidationErrors } from '#utils/schema/schema.types';\n\n/**\n * This builds on top of the react-hook-form library\n * to provide a consistent handling of form state\n *\n * Designed to be used with TextInput & PasswordInput\n * and could be extended to support other input types\n *\n */\nconst useIndyForm = <T extends FieldValues>(\n  schema: Schema<T>,\n  options: UseFormProps<T> = {},\n) => {\n  if (!schema) {\n    throw new Error(\n      'No schema provided! Please provide a schema to useIndyForm',\n    );\n  }\n\n  const methods = useForm<T>({\n    mode: 'onTouched',\n    resolver: resolver<T>(schema as Schema<T>),\n    ...options,\n  });\n\n  const { formState, getValues, setError } = methods;\n\n  useEffect(() => {\n    const schemaFields = schema.fields;\n    const formFields = Object.keys(getValues());\n\n    const missingFields = schemaFields.filter(\n      (field) => !formFields.includes(field as string),\n    );\n\n    if (missingFields.length > 0) {\n      throw new Error(\n        `Fields [\"${missingFields.join(\n          '\", \"',\n        )}\"] are included in the schema but missing or inaccessible by React Hook Form`,\n      );\n    }\n  }, [getValues, schema.fields]);\n\n  const getTextInputError = (id: keyof T) => {\n    const formErrors = formState.errors as ValidationErrors<T>;\n    const textInputErrors = formErrors[id];\n\n    if (textInputErrors) {\n      return textInputErrors[0].messageBuilder(schema.names[id]);\n    }\n\n    return undefined;\n  };\n\n  const getTextInputState = (id: keyof T) => {\n    const formErrored = !!formState.errors['root'];\n    const fieldIsErrored = !!formState.errors[id];\n    const fieldHasErrored =\n      formState.dirtyFields[id as string] && !fieldIsErrored;\n\n    if (fieldIsErrored || formErrored) {\n      return InputState.ERROR;\n    }\n\n    if (fieldHasErrored) {\n      return InputState.SUCCESS;\n    }\n\n    return InputState.DEFAULT;\n  };\n\n  const registerControlledInput = (id: keyof T) => {\n    const fieldIsRequired = schema.get(id)?.isRequired || false;\n    const fieldError = getTextInputError(id);\n    const fieldState = getTextInputState(id);\n\n    return {\n      id: id as keyof T,\n      state: fieldState,\n      message: fieldError,\n      required: fieldIsRequired,\n      'aria-required': fieldIsRequired,\n      'aria-invalid': fieldError === 'error',\n      // Feb 2024 - errors should be announced by aria-errormessage in the future,\n      // but it is currently not well supported sccross screen readers/browsers\n      'aria-describedby': `${errorId(id)} ${hintId(id)}`,\n    };\n  };\n\n  const setFormError = (message: string) => {\n    setError('root', { message });\n  };\n\n  const setFieldError = (name: Path<T>, message: string) => {\n    setError(name, { message }, { shouldFocus: true });\n  };\n\n  const getFormError = () => getTextInputError('root');\n  const getFieldErrors = () =>\n    schema.fields.map(getTextInputError).filter(Boolean) as string[];\n  const getFieldValidationHints = (id: keyof T) => {\n    return schema.validationHints[id];\n  };\n  return {\n    registerControlledInput,\n    methods: {\n      ...methods,\n      setFormError,\n      setFieldError,\n      getFormError,\n      getFieldErrors,\n      getFieldValidationHints,\n    },\n    formState: {\n      ...formState,\n      errors: formState.errors as ValidationErrors<T>,\n    },\n  };\n};\n\nexport default useIndyForm;\n","import React from 'react';\nimport { SubmitHandler } from 'react-hook-form';\n\nimport Button from '#components/Button';\nimport {\n  Form,\n  FormProvider,\n  TextInput,\n  PasswordInput,\n  SelectInput,\n  Schema,\n} from '#components/Form';\n\nimport { Wrapper } from './TestableForm.styles';\n\nimport useIndyForm from '#hooks/useIndyForm';\n\ntype ExampleFormData = {\n  fullName: string;\n  email: string;\n  password: string;\n  birthYear: string;\n};\n\ntype TestableFormProps = { onSubmit: SubmitHandler<ExampleFormData> };\n\nexport const schema = new Schema<ExampleFormData>({\n  fullName: Schema.add('Full name').string(),\n  email: Schema.add('Email address').string().isEmail().required(),\n  password: Schema.add('Password')\n    .string()\n    .hasMin(1, 'digits')\n    .hasMin(6, 'letters')\n    .required(),\n  birthYear: Schema.add('Birth year').number().required(),\n});\n\n/**\n * This form exists to demonstrate how to use the useIndyForm hook\n * alongside the Form, TextInput and PasswordInput components\n *\n * It us also used for testing functionality in a form context\n * with full validation and error handling, and providing a\n * component in storybook for visual testing\n */\nconst TestableForm: React.FC<TestableFormProps> = ({ onSubmit }) => {\n  const { methods, registerControlledInput } = useIndyForm(schema);\n  const { handleSubmit, formState } = methods;\n\n  return (\n    <Wrapper>\n      <FormProvider {...methods}>\n        <Form>\n          <TextInput label=\"Name\" {...registerControlledInput('fullName')} />\n          <TextInput\n            type=\"email\"\n            label=\"Email address\"\n            helpText=\"Add an email address\"\n            {...registerControlledInput('email')}\n          />\n          <PasswordInput\n            label=\"Password\"\n            helpText=\"Make it a good one\"\n            {...registerControlledInput('password')}\n          />\n          <SelectInput\n            label=\"Birth year\"\n            options={[\n              { value: '1970', label: '1970' },\n              { value: '1980', label: '1980' },\n              { value: '1990', label: '1990' },\n            ]}\n            {...registerControlledInput('birthYear')}\n          ></SelectInput>\n          <Button\n            type=\"submit\"\n            disabled={!formState.isValid}\n            onClick={handleSubmit(onSubmit)}\n          >\n            Sign up\n          </Button>\n        </Form>\n      </FormProvider>\n    </Wrapper>\n  );\n};\n\nexport default TestableForm;\n"],"names":["Form","__name","children","preventSubmission","e","jsx","props","handler","type","condition","message","messageBuilder","isString","validate","value","parseString","fieldName","isNumber","isNumeric","isNaN","isBoolean","isNotEmpty","length","isEmail","parsedValue","RegExp","test","doesMatch","values","isMatchingField","hasMin","minLen","countType","len","count","defaults","capitalise","hasMax","maxLength","hasRange","minLength","Number","containsNoSpaces","includes","matchesRegex","regex","hasCustomValidation","validator","NO_PARAMS","SchemaEntry","constructor","name","primitiveType","isRequired","validators","initialise","fns","checkValid","Error","string","number","boolean","required","args","push","params","Schema","schema","self","fields","names","errors","validationHints","Object","keys","entries","reduce","acc","key","initValidationHints","add","get","field","getErrors","setErrors","getValidationHints","setValidationHints","passes","hint","initValidationHint","forEach","validatorCreator","val","label","join","resetValidationHints","entry","fieldEmptyError","freshErrorsFiltered","Promise","all","map","creator","error","filter","Wrapper","styled","div","withConfig","componentId","theme","spacing","x2","useIndyForm","options","methods","useForm","mode","resolver","formState","getValues","setError","useEffect","schemaFields","formFields","missingFields","getTextInputError","id","textInputErrors","undefined","getTextInputState","formErrored","fieldIsErrored","fieldHasErrored","dirtyFields","InputState","ERROR","SUCCESS","DEFAULT","registerControlledInput","fieldIsRequired","fieldError","fieldState","state","errorId","hintId","setFormError","setFieldError","shouldFocus","getFormError","getFieldErrors","Boolean","getFieldValidationHints","TestableForm","onSubmit","handleSubmit","FormProvider","jsxs","TextInput","PasswordInput","SelectInput","Button"],"mappings":"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"}